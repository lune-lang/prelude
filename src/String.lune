export
  type string, isEmpty, length,
  (<>), concat, concatMap, join, joinMap,
  repeat, reverse,
  split, words, lines,
  slice, takeLeft, takeRight, dropLeft, dropRight,
  toLower, toUpper,
  padLeft, padRight, trim, trimLeft, trimRight,
  contains, startsWith, endsWith,
  find, replace,
  toInt, fromInt, toFloat, fromFloat,
  toList, fromList,
  cons, deconstruct,
  single, head, tail, get,
  map, mapIndex,
  filter, partition, count, some, all,
  foldLeft, foldRight

import Prelude open
import Char exposing type char
import List exposing type list
import Result exposing type maybe, nothing

infix <> left 60

type string :: Type
syntax string string-type

val isEmpty :: string -> bool
let isEmpty str = str == ""

foreign length :: string -> int

foreign (<>) :: string -> string -> string

val concat :: list string -> string
let concat = List.foldRight (<>) ""

val concatMap :: any a. (a -> string) -> list a -> string
let concatMap f xs = concat (List.map f xs)

val join :: string -> list string -> string
let join sep = def
  let append str1 str2 =
    if (isEmpty str2) { str1 }
    { str1 <> sep <> str2 }
  in List.foldRight append ""

val joinMap :: any a. string -> (a -> string) -> list a -> string
let joinMap sep f xs = join sep (List.map f xs)

val repeat :: int -> string -> string
let repeat n str = if (n <= 0) { "" } { str <> repeat (n ~ 1) str }

foreign reverse :: string -> string

foreign split :: string -> string -> list string

foreign words, lines :: string -> list string

foreign slice :: int -> int -> string -> string

val takeLeft :: int -> string -> string
let takeLeft x str = if (x <= 0) { "" } { slice 0 x str }

val takeRight :: int -> string -> string
let takeRight x str = if (x <= 0) { "" } { slice -x (length str) str }

val dropLeft :: int -> string -> string
let dropLeft x str = if (x <= 0) { str } { slice x (length str) str }

val dropRight :: int -> string -> string
let dropRight x str = if (x <= 0) { str } { slice 0 -x str }

foreign toLower, toUpper :: string -> string

val padLeft, padRight :: int -> string -> string
let padLeft x str = if (length str >= x) { str } { " " <> padLeft (x ~ 1) str }
let padRight x str = if (length str >= x) { str } { padRight (x ~ 1) str <> " " }

foreign trim, trimLeft, trimRight :: string -> string

foreign contains, startsWith, endsWith :: string -> string -> bool

val find :: string -> string -> list int
let find sub str = def
  let matches i = startsWith sub (dropLeft i str)
  in List.filter matches $ List.range 0 (length str)

foreign replace :: string -> string -> string -> string

foreign toInt :: string -> maybe int

foreign fromInt :: int -> string

foreign toFloat :: string -> maybe float

foreign fromFloat :: float -> string

foreign toList :: string -> list char

foreign fromList :: list char -> string

foreign cons :: char -> string -> string

foreign deconstruct :: any a. a -> (char -> string -> a) -> string -> a

foreign single :: char -> string

val head :: string -> maybe char
let head = deconstruct nothing do c str. Just ^ c

val tail :: string -> maybe string
let tail = deconstruct nothing do c str. Just ^ str

val get :: int -> string -> maybe char
let get x =
  deconstruct nothing do c str.
    if (x < 0) { nothing }
    $ else $ if (x == 0) { Just ^ c }
    $ else $ get (x ~ 1) str

val map :: (char -> char) -> string -> string
let map f = deconstruct "" do c str. cons (f c) (map f str)

val mapIndex :: (int -> char -> char) -> string -> string
let mapIndex = mapIndexN 0

val mapIndexN :: int -> (int -> char -> char) -> string -> string
let mapIndexN x f =
  deconstruct "" do c str.
    cons (f x c) $ mapIndexN (x + 1) f str

val filter :: (char -> bool) -> string -> string
let filter f = def
  let add c str = if (f c) { cons c str } { str }
  in foldRight add ""

val partition :: (char -> bool) -> string -> string & string
let partition f = def
  let add c str = if (f c) { First #= cons c; str } { Second #= cons c; str }
  in foldRight add ("" & "")

val count :: (char -> bool) -> string -> int
let count f = def
  let add c x = if (f c) { x + 1 } { x }
  in foldRight add 0

val some :: (char -> bool) -> string -> bool
let some f =
  deconstruct false do c str.
    if (f c) { true } { some f str }

val all :: (char -> bool) -> string -> bool
let all f =
  deconstruct true do c str.
    if (not $ f c) { false } { all f str }

val foldLeft :: any a. (a -> char -> a) -> a -> string -> a
let foldLeft f x =
  deconstruct x do c str.
    f (foldLeft f x str) c

val foldRight :: any a. (char -> a -> a) -> a -> string -> a
let foldRight f x =
  deconstruct x do c str.
    f c (foldRight f x str)
