export
  type list, empty, (:), deconstruct, single,
  head, tail, take, drop, get,
  isEmpty, length,
  (++), concat, repeat, reverse, range,
  contains, find,
  map, concatMap, mapIndex, mapResult, separate,
  filter, partition, count, some, all,
  foldLeft, foldRight, sum, product,
  sort, sortBy, sortWith,
  apply, map2, map3, map4,
  zipApply, zip2, zip3, zip4

import Prelude open
import Result exposing type result, type maybe, nothing

infix : right 55
infix ++ right 55

type list :: Type -> Type
  where list a = [Empty := void; Cons := {Head := a; Tail := list a; nil}; nil]
  with makeList, getList

val empty :: any a. list a
let empty = makeList (only Empty)

val (:) :: any a. a -> list a -> list a
let (:) x xs = makeList $ Cons ^ (Head := x; Tail := xs; void)

val deconstruct :: any a b. b -> (a -> list a -> b) -> list a -> b
let deconstruct x f xs = getList xs # match Cons (do r. f (Head ? r) (Tail ? r)) $ else x

val single :: any a. a -> list a
let single x = x : empty

val head :: any a. list a -> maybe a
let head = deconstruct nothing do x xs. Just ^ x

val tail :: any a. list a -> maybe (list a)
let tail = deconstruct nothing do x xs. Just ^ xs

val take :: any a. int -> list a -> list a
let take n xs =
  if (n <= 0) empty
  $ deconstruct empty (do x xt. x : take (n ~ 1) xt) xs

val drop :: any a. int -> list a -> list a
let drop n xs =
  if (n <= 0) xs
  $ deconstruct empty (do x xt. drop (n ~ 1) xt) xs

val get :: any a. int -> list a -> maybe a
let get n =
  deconstruct nothing do x xs.
    if (n < 0) nothing
    $ if (n == 0) (Just ^ x)
    $ get (n ~ 1) xs

val isEmpty :: any a. list a -> bool
let isEmpty = deconstruct false do x xs. true

val length :: any a. list a -> int
let length = deconstruct 0 do x xs. 1 + length xs

val (++) :: any a. list a -> list a -> list a
let (++) xs ys = xs # deconstruct ys do x xt. x : xt ++ ys

val concat :: any a. list (list a) -> list a
let concat = foldRight (++) empty

val concatMap :: any a b. (a -> list b) -> list a -> list b
let concatMap f xs = concat (map f xs)

val repeat :: any a. int -> a -> list a
let repeat n x =
  if (n <= 0) empty
  $ x : repeat (n ~ 1) x

val reverse :: any a. list a -> list a
let reverse = deconstruct empty do x xs. reverse xs ++ single x

val range :: int -> int -> list int
let range m n =
  if (n <= m) empty
  $ m : range (m + 1) n

val contains :: any a. a -> list a -> bool
let contains x = some (== x)

val find :: any a. a -> list a -> list int
let find = findN 0

val findN :: any a. int -> a -> list a -> list int
let findN n x =
  deconstruct empty do y ys. def
    let indexes = findN (n + 1) x ys
    in if (x == y) (n : indexes) indexes

val map :: any a b. (a -> b) -> list a -> list b
let map f = deconstruct empty do x xs. f x : map f xs

val mapIndex :: any a b. (int -> a -> b) -> list a -> list b
let mapIndex = mapIndexN 0

val mapIndexN :: any a b. int -> (int -> a -> b) -> list a -> list b
let mapIndexN n f =
  deconstruct empty do x xs.
    f n x : mapIndexN (n + 1) f xs

val mapResult :: any e a b. (a -> result e b) -> list a -> list b
let mapResult f = def
  let add x xs = f x # match Just (: xs) $ else xs
  in foldRight add empty

val separate :: any a b. list (a & b) -> list a & list b
let separate = def
  let add x xs =
    First #= ((First ? x) :)
    ; Second #= ((Second ? x) :)
    ; xs
  in foldRight add (empty & empty)

val filter :: any a. (a -> bool) -> list a -> list a
let filter f = def
  let add x xs = if (f x) (x : xs) xs
  in foldRight add empty

val partition :: any a. (a -> bool) -> list a -> list a & list a
let partition f = def
  let add x xs = if (f x) (First #= (x :); xs) (Second #= (x :); xs)
  in foldRight add (empty & empty)

val count :: any a. (a -> bool) -> list a -> int
let count f = def
  let add x n = if (f x) (n + 1) n
  in foldRight add 0

val some :: any a. (a -> bool) -> list a -> bool
let some f =
  deconstruct false do x xs.
    if (f x) true (some f xs)

val all :: any a. (a -> bool) -> list a -> bool
let all f =
  deconstruct true do x xs.
    if (not $ f x) false (all f xs)

val foldLeft :: any a b. (b -> a -> b) -> b -> list a -> b
let foldLeft f n =
  deconstruct n do x xs.
    f (foldLeft f n xs) x

val foldRight :: any a b. (a -> b -> b) -> b -> list a -> b
let foldRight f n =
  deconstruct n do x xs.
    f x (foldRight f n xs)

val sum :: any x. list (num x) -> num x
let sum = foldRight (+) 0

val product :: any x. list (num x) -> num x
let product = foldRight (*) 1

val sort :: any a. list a -> list a
let sort = sortBy identity

val sortBy :: any a b. (a -> b) -> list a -> list a
let sortBy f =
  deconstruct empty do x xs. def
    let half = partition (do y. f y < f x) xs
    in sortBy f (First ? half) ++ single x ++ sortBy f (Second ? half)

val sortWith :: any a. (a -> a -> order) -> list a -> list a
let sortWith f =
  deconstruct empty do x xs. def
    let half = partition (do y. f y x == only Less) xs
    in sortWith f (First ? half) ++ single x ++ sortWith f (Second ? half)

val apply :: any a b. list (a -> b) -> list a -> list b
let apply fs xs = fs # deconstruct empty do f ft. map f xs ++ apply ft xs

val map2
  :: any a1 a2 a3
   . (a1 -> a2 -> a3)
  -> list a1
  -> list a2
  -> list a3
let map2 f xs = apply (map f xs)

val map3
  :: any a1 a2 a3 a4
   . (a1 -> a2 -> a3 -> a4)
  -> list a1
  -> list a2
  -> list a3
  -> list a4
let map3 f xs1 xs2 = apply (map2 f xs1 xs2)

val map4
  :: any a1 a2 a3 a4 a5
   . (a1 -> a2 -> a3 -> a4 -> a5)
  -> list a1
  -> list a2
  -> list a3
  -> list a4
  -> list a5
let map4 f xs1 xs2 xs3 = apply (map3 f xs1 xs2 xs3)

val zipApply :: any a b. list (a -> b) -> list a -> list b
let zipApply fs xs =
  fs # deconstruct empty do f ft.
    xs # deconstruct empty do x xt.
      f x : zipApply ft xt

val zip2
  :: any a1 a2 a3
   . (a1 -> a2 -> a3)
  -> list a1
  -> list a2
  -> list a3
let zip2 f xs = zipApply (map f xs)

val zip3
  :: any a1 a2 a3 a4
   . (a1 -> a2 -> a3 -> a4)
  -> list a1
  -> list a2
  -> list a3
  -> list a4
let zip3 f xs1 xs2 = zipApply (zip2 f xs1 xs2)

val zip4
  :: any a1 a2 a3 a4 a5
   . (a1 -> a2 -> a3 -> a4 -> a5)
  -> list a1
  -> list a2
  -> list a3
  -> list a4
  -> list a5
let zip4 f xs1 xs2 xs3 = zipApply (zip3 f xs1 xs2 xs3)
