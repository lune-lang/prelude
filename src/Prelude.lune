export
  type (->), identity, const,
  ($), (#), (<<), (>>),
  type i, type f, type num, type int, type float,
  float, round, floor, ceil, trunc,
  (+), (~), (*), negate, abs, signum, constrain,
  div, quot, mod, rem, (/),
  type nil, type (:=), type (;),
  type record, type variant, type label, type void,
  void, (?), delete, (:=), (!=), (#=), (;),
  (^), embed, match, else, only,
  type lazy, force, general,
  type (&), (&),
  type bool, true, false, not, (&&), (||), if,
  (==), (/=), (<), (<=), (>), (>=),
  isFinite, isInfinite, isNaN,
  min, max, type order, compare

infix ; right 10

infix := non 15
infix != non 15
infix #= non 15

infix # left 20

infix $ right 25

infix -> right 30

infix & right 35

infix || right 40

infix && right 45

infix == non 50
infix /= non 50
infix < non 50
infix <= non 50
infix > non 50
infix >= non 50

infix + left 60
infix ~ left 60

infix * left 65
infix / left 65

infix ? right 70
infix ^ right 70

infix << right 75
infix >> left 75

type (->) :: Type -> Type -> Type
syntax (->) function-type

val identity :: any a. a -> a
let identity x = x

val const :: any a b. a -> b -> a
let const x y = x

val ($) :: any a b. (a -> b) -> a -> b
let ($) f x = f x

val (#) :: any a b. a -> (a -> b) -> b
let (#) x f = f x

val (<<) :: any a b c. (b -> c) -> (a -> b) -> (a -> c)
let (<<) f g x = f (g x)

val (>>) :: any a b c. (a -> b) -> (b -> c) -> (a -> c)
let (>>) g f x = f (g x)

type i :: Num
type f :: Num
type num :: Num -> Type
syntax num number-type

type int = num i
type float = num f
syntax float float-type

foreign float :: int -> float

foreign round, floor, ceil :: float -> int

val trunc :: float -> int
let trunc x = if (x < 0) { ceil x } { floor x }

foreign (+), (~), (*) :: any x. num x -> num x -> num x

foreign negate :: any x. num x -> num x
syntax negate negate-function

foreign abs, signum :: any x. num x -> num x

val constrain :: any x. num x -> num x -> num x -> num x
let constrain x y z =
  if (z <= x) { x }
  $ else $ if (z >= y) { y }
  $ else $ z

foreign div, quot :: int -> int -> int

foreign mod, rem :: int -> int -> int

foreign (/) :: float -> float -> float

type nil :: Row
type (:=) :: Label -> Type -> Row -> Row
syntax (:=) row-constructor

type (;) f x = f x

type record :: Row -> Type
syntax record curly-brackets

type variant :: Row -> Type
syntax variant square-brackets

type label :: Label -> Type
syntax label label-type

type void = {nil}

foreign void :: void

foreign (?) :: any s a r. label s -> {s := a; r} -> a

foreign delete :: any s a r. label s -> {s := a; r} -> {r}

foreign (:=) :: any s a r. label s -> a -> {r} -> {s := a; r}

val (!=) :: any s a b r. label s -> b -> {s := a; r} -> {s := b; r}
let (!=) s x r = s := x; delete s r

val (#=) :: any s a b r. label s -> (a -> b) -> {s := a; r} -> {s := b; r}
let (#=) s f r = s != f (s ? r); r

val (;) :: any a b. (a -> b) -> a -> b
let (;) f x = f x

foreign (^) :: any s a r. label s -> a -> [s := a; r]

foreign embed :: any s a r. label s -> [r] -> [s := a; r]

foreign match :: any s a b r. label s -> (a -> b) -> ([r] -> b) -> [s := a; r] -> b

val else :: any a b. a -> b -> a
let else x y = x

val only :: any s r. label s -> [s := void; r]
let only s = s ^ void

type lazy a = void -> a

val force :: any a. lazy a -> a
let force f = f void

val general :: any a b. lazy a -> b -> a
let general f x = f void

type (&) a b = {First := a; Second := b; nil}

val (&) :: any a b. a -> b -> a & b
let (&) x y = First := x; Second := y; void

type bool = [True := void; False := void; nil]

val true, false :: bool
let true = only True
let false = only False

val not :: bool -> bool
let not = match True { false } { true }

val and, or :: bool -> lazy bool -> bool
let and x y = x # match True y { false }
let or x y = x # match True { true } (general y)

expand (&&) x y = and x { y }
expand (||) x y = or x { y }

val if :: any a. bool -> lazy a -> lazy a -> a
let if c x y = c # match True x (general y)

foreign (==) :: any a. a -> a -> bool

val (/=) :: any a. a -> a -> bool
let (/=) x y = not (x == y)

foreign (<), (>) :: any a. a -> a -> bool

val (<=), (>=) :: any a. a -> a -> bool
let (<=) x y = x < y || x == y
let (>=) x y = x > y || x == y

foreign isFinite :: float -> bool

val isInfinite :: float -> bool
let isInfinite x = not (isFinite x || isNaN x)

foreign isNaN :: float -> bool

val min, max :: any a. a -> a -> a
let min x y = if (x < y) { x } { y }
let max x y = if (x > y) { x } { y }

type order = [Less := void; Equal := void; Greater := void; nil]

val compare :: any a. a -> a -> order
let compare x y =
  if (x == y) { only Equal }
  $ else $ if (x < y) { only Less }
  $ else $ only Greater
