export
  type (->), identity, const,
  ($), (#), (<<), (>>),
  type i, type f, type num, type int, type float,
  float, round, floor, ceil, trunc,
  (+), (~), (*), negate, abs, signum, constrain,
  div, quot, mod, rem, (/),
  type nil, type (:=), type (|), type (;),
  type record, type variant, type label, type void,
  void, (?), delete, (:=), (!=), (#=), (;),
  (^), embed, match, else, absurd, only,
  type lazy, force, general,
  type (&), (&),
  type bool, true, false, not, (&&), (||), if,
  (==), (/=), (<), (<=), (>), (>=),
  isFinite, isInfinite, isNaN,
  min, max, type order, compare

infix ; right 10
infix | right 10

infix := non 15
infix != non 15
infix #= non 15

infix # left 20

infix $ right 25

infix -> right 30

infix & right 35

infix || right 40

infix && right 45

infix == non 50
infix /= non 50
infix < non 50
infix <= non 50
infix > non 50
infix >= non 50

infix + left 60
infix ~ left 60

infix * left 65
infix / left 65

infix ? right 70
infix ^ right 70

infix << right 75
infix >> left 75

{- ### Functions -}

type (->) :: Type -> Type -> Type
syntax (->) function-type
{-
The type of functions. For example, a function that takes an integer and
returns a string would have the type `int -> string`.
-}

val identity :: any a. a -> a
let identity x = x
{-
A function that does nothing. `identity x` is equivalent to `x`.
-}

val const :: any a b. a -> b -> a
let const x y = x
{-
`const x` is a function that ignores its argument and returns `x`.
You can also use the notation `{ x }`.
-}

expand ($) f x = f x
{-
Apply the function on the left to the value on the right.
The `$` operator has a relatively low precedence,
so it is useful for avoiding parentheses. For example `f (g (h x))`
can be written `f $ g $ h x`.
-}

expand (#) x f = f x
{-
Apply the function on the right to the value on the left.
For example, `f (g (h x)) can be written h x # g # f`.
-}

val (<<) :: any a b c. (b -> c) -> (a -> b) -> (a -> c)
let (<<) f g x = f (g x)
{-
Right-to-left function composition. `f << g` performs `g` and then `f`.
-}

val (>>) :: any a b c. (a -> b) -> (b -> c) -> (a -> c)
let (>>) g f x = f (g x)
{-
Left-to-right function composition. `f >> g` performs `f` and then `g`.
-}

{- ### Numerical types and conversions -}

type i :: Num
type f :: Num
type num :: Num -> Type
syntax num number-type
{-
The type-level values `i` and `f` are of a different _kind_ than normal types.
You can convert them into types with the constructor `num`; `num i` is
the type of integers and `num f` is the type of floats. You
can define functions that work on both integers and floats by writing
`any x. num x`.
-}

type int = num i
{-
The type of integers. Lune compiles to Javascript, so integers and floats
have the same representation at runtime. Nevertheless, the Lune type system
distinguishes the two, because there are some computations (such as `mod`)
that only make sense with integers.
-}

type float = num f
syntax float float-type
{-
The type of floating-point numbers.
-}

foreign float :: int -> float
{-
Convert an integer into a float. Lune does not perform such coercions implicitly.
-}

foreign round :: float -> int
{-
Round a number to the nearest integer.
-}

foreign floor :: float -> int
{-
Round a number down.
```
floor 1.5 == 1
floor -1.5 == -2
```
-}

foreign ceil :: float -> int
{-
Round a number up.
```
ceil 1.5 == 2
ceil -1.5 == -1
```
-}

val trunc :: float -> int
let trunc x = if (x < 0) { ceil x } { floor x }
{-
If the input is less than zero, round up; otherwise, round down.
In other words, get rid of everything after the decimal point.
```
trunc 1.5 == 1
trunc -1.5 == -1
```
-}

{- ### Mathematical operations -}

foreign (+), (~), (*) :: any x. num x -> num x -> num x
{-
Addition, subtraction, and multiplication.

Why is subtraction denoted with `~`?
Well, consider the following expressions:
```
x -y
(-z)
```
Should `x -y` be interpreted as subtraction? Or is it applying a function to a
negative number? And is `(-z)` a negation or an operator section? I have
decided to avoid these ambiguities by denoting subtraction with `~` and
negation with `-`.
-}

foreign negate :: any x. num x -> num x
syntax negate negate-function
{-
Negate a number. `-x` is syntactic sugar for `negate x`.
-}

foreign abs :: any x. num x -> num x
{-
Take the absolute value of a number.
-}

foreign signum :: any x. num x -> num x
{-
Find the "sign" of a number. For positive numbers, `signum` returns 1,
for negative numbers, it returns -1, and for 0, it returns 0. Note that
`abs x * signum x` is equal to `x`.
-}

val constrain :: any x. num x -> num x -> num x -> num x
let constrain x y z =
  if (z <= x) { x }
  $ else $ if (z >= y) { y }
  $ else $ z
{-
Constrain a number between a lower bound (the first argument) and an
upper bound (the second argument). For example, `constrain 0 10 11` is
equal to `10`, and `constrain 0 10 5` is equal to `5`.
-}

foreign div, quot :: int -> int -> int
{-
Integer division. `div` rounds the result down, and `quot` truncates it.
For positive arguments, these are the same thing.

__Haskellers beware:__ the arguments to `div` and `quot` are the opposite
of the Haskell definitions. `div 2` is a function that divides a number by 2,
so `div 2 10` is equal to 5.
-}

foreign mod, rem :: int -> int -> int
{-
Integer modulo. `mod` represents actual modulo, and `rem` is the
so-called "modulo" operation written with a `%` in most languages.
The difference only matters with negative arguments: `mod 3 -1` evaluates to
2, but `rem 3 -1` evaluates to -1.

__Haskellers beware:__ the arguments to `mod` and `rem` are the opposite
of the Haskell definitions. `mod 2` is a function that mods a number by 2,
so `mod 2 10` is equal to 0.
-}

foreign (/) :: float -> float -> float
{-
Floating-point division.
-}

type nil :: Row
type (:=) :: Label -> Type -> Row -> Row
syntax (:=) row-constructor

type (|) s = s := void

type (;) f x = f x

type record :: Row -> Type
syntax record curly-brackets

type variant :: Row -> Type
syntax variant square-brackets

type label :: Label -> Type
syntax label label-type

type void = {nil}

foreign void :: void

foreign (?) :: any s a r. label s -> {s := a; r} -> a

foreign delete :: any s a r. label s -> {s := a; r} -> {r}

foreign (:=) :: any s a r. label s -> a -> {r} -> {s := a; r}

val (!=) :: any s a b r. label s -> b -> {s := a; r} -> {s := b; r}
let (!=) s x r = s := x; delete s r

val (#=) :: any s a b r. label s -> (a -> b) -> {s := a; r} -> {s := b; r}
let (#=) s f r = s != f (s ? r); r

val (;) :: any a b. (a -> b) -> a -> b
let (;) f x = f x

foreign (^) :: any s a r. label s -> a -> [s := a; r]

foreign embed :: any s a r. label s -> [r] -> [s := a; r]

foreign match :: any s a b r. label s -> (a -> b) -> ([r] -> b) -> [s := a; r] -> b

val else :: any a b. a -> b -> a
let else x y = x

val absurd :: any a. [nil] -> a
let absurd = absurd

val only :: any s r. label s -> [s := void; r]
let only s = s ^ void

type lazy a = void -> a

val force :: any a. lazy a -> a
let force f = f void

val general :: any a b. lazy a -> b -> a
let general f x = f void

type (&) a b = {First := a; Second := b; nil}

val (&) :: any a b. a -> b -> a & b
let (&) x y = First := x; Second := y; void

type bool = [True := void; False := void; nil]

val true, false :: bool
let true = only True
let false = only False

val not :: bool -> bool
let not = match True { false } { true }

val and, or :: bool -> lazy bool -> bool
let and x y = x # match True y { false }
let or x y = x # match True { true } (general y)

expand (&&) x y = and x { y }
expand (||) x y = or x { y }

val if :: any a. bool -> lazy a -> lazy a -> a
let if c x y = c # match True x (general y)

foreign (==) :: any a. a -> a -> bool

val (/=) :: any a. a -> a -> bool
let (/=) x y = not (x == y)

foreign (<), (>) :: any a. a -> a -> bool

val (<=), (>=) :: any a. a -> a -> bool
let (<=) x y = x < y || x == y
let (>=) x y = x > y || x == y

foreign isFinite :: float -> bool

val isInfinite :: float -> bool
let isInfinite x = not (isFinite x || isNaN x)

foreign isNaN :: float -> bool

val min, max :: any a. a -> a -> a
let min x y = if (x < y) { x } { y }
let max x y = if (x > y) { x } { y }

type order = [Less := void; Equal := void; Greater := void; nil]

val compare :: any a. a -> a -> order
let compare x y =
  if (x == y) { only Equal }
  $ else $ if (x < y) { only Less }
  $ else $ only Greater
